<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Max Heap Visualizer</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="css/heap.css">
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css">
</head>

<body>
    <nav class="navigation-bar">
        <h1>MaxHeap</h1>
        <section class="info-section">
            <p class="size-output">Size: 0</p>
            <p class="isEmpty-output">isEmpty? true</p>
        </section>
        <section class="input-section">
            <input type="text" class="node-value" placeholder="Enter Node Value">
            <button class="add-btn">Add</button>
            <button class="extract-btn">Extract Max</button>
            <button class="array-btn">Toggle Array</button>
            <button class="clear-btn">Clear Heap</button>
            <button class="open-btn">Info</button>
        </section>
    </nav>

    <section class="parent-section">
        <section class="info-section">
            <p class="error-msg" id="error-msg">Please Enter a Valid Number</p>
        </section>
    </section>

    <main>
        <!-- Heap Contents Will be rendered here-->
        <div class="maxheap-container"></div>
    </main>

    <section class="modal">
        <aside>
            <h2>Max Heap - Array Zero Based Index</h2>
            <button class="close-btn">Close</button>
        </aside>

        <section class="information">
            <h2>A max heap must satisfy three invariants</h2>
            <ul>
                <li>Every node must have at most two children (Binary Tree)</li>
                <li>Every node is greater than or equal to it's children (Max Heap Invariant)</li>
                <li>Each level is complete meaning it has no gaps. Heaps are filled up left to right. (Max Heap
                    Structure
                    Invariant)
                </li>
            </ul>
        </section>

        <section class="about">
            <h2>About the methods</h2>
            <ul>
                <li>add() inserts a node on the bottom level to ensure no gaps, then we fix any heap invariants
                    with heapifyUp() which means we swap with parent until your parent is greater than you or
                    you are the root.
                </li>
                <li>removeMax() returns the max node. Then we replace the bottom level right-most node. Finally,
                    we heapifyDown() which means we recursively swap with the greatest child until parent is greater
                    than both children or we're at a leaf.
                </li>
            </ul>
        </section>

        <section class="all">
            <article class="java-article">
                <h2>Java</h2>
                <pre>
                <code class="language-java">
    import java.util.ArrayList;
    import java.util.List;

    public class MaxHeap {
        private List<Integer> data;
        private int size;

        public MaxHeap() {
            super();
            this.data = new ArrayList<>();
            this.size = 0;
        }

        private int getParentIndex(int index) {
            if (index <= 0) {
                return 0;
            }
            return (index - 1) / 2;
        }

        private int getLeftChildIndex(int index) {
            return index * 2 + 1;
        }

        private int getRightChildIndex(int index) {
            return index * 2 + 2;
        }

        public void add(int value) {
            if (!data.contains(value)) {
                data.add(size, value);
                size++;
                createHeapLevels();
                isEmpty();
                getSize();
                heapifyUp();
            }
        }

        public Integer extractMax() {
            if (size == 0) {
                return null;
            }
            int firstIndex = 0;
            swap(firstIndex, size - 1);
            int max = data.remove(size - 1);
            startExtractMaxAnimation(firstIndex, size - 1);
            size--;
            getSize();
            isEmpty();
            heapifyDown(firstIndex);
            return max;
        }

        private void swap(int index1, int index2) {
            int temp = data.get(index1);
            data.set(index1, data.get(index2));
            data.set(index2, temp);
            startSwapAnimation(index1, index2);
        }

        private void heapifyUp() {
            int lastIndex = size - 1;
            while (data.get(getParentIndex(lastIndex)) < data.get(lastIndex)) {
                int parentIndex = getParentIndex(lastIndex);
                swap(parentIndex, lastIndex);
                lastIndex = parentIndex;
            }
        }

        private void heapifyDown(int firstIndex) {
            while (getLeftChildIndex(firstIndex) < size) {
                int biggestSiblingIndex = getLeftChildIndex(firstIndex);
                if (getRightChildIndex(firstIndex) < size
                        && data.get(getRightChildIndex(firstIndex)) > data.get(biggestSiblingIndex)) {
                    biggestSiblingIndex = getRightChildIndex(firstIndex);
                }
                if (data.get(firstIndex) < data.get(biggestSiblingIndex)) {
                    swap(firstIndex, biggestSiblingIndex);
                    firstIndex = biggestSiblingIndex;
                } else {
                    return;
                }
            }
        }

        public int getSize() {
            System.out.println("Size: " + size);
            return size;
        }

        public boolean isEmpty() {
            System.out.println("isEmpty? " + (size == 0));
            return size == 0;
        }

        public boolean contains(int value) {
            return data.contains(value);
        }

        public void clear() {
            List<Node> allNodes = getAllNodes();
            for (int index = 0; index < allNodes.size(); index++) {
                Node node = allNodes.get(index);
                final int finalIndex = index;
            }
            data.clear();
            size = 0;
            isEmpty();
            getSize();
        }

        public void buildMaxHeap() {
            // not used
            int lastNonLeafIndex = size / 2 - 1;
            for (int i = lastNonLeafIndex; i >= 0; i--) {
                heapifyDown(i);
            }
        }

        public String toString() {
            StringBuilder result = new StringBuilder("[");
            for (int index = 0; index < size; index++) {
                result.append(data.get(index));
                if (index < size - 1) {
                    result.append(", ");
                }
            }
            result.append("]");
            return result.toString();
        }
    }
        </code>
    </pre>
            </article>

            <article class="c-article">
                <h2>C</h2>
                <pre>
                <code class="language-c">
    #include stdio.h
    #include stdbool.h
    #include stdlib.h
      
    typedef struct {
        int* data;
        int size;
    } MaxHeap;
    
    int getParentIndex(int index) {
        if (index <= 0) {
            index = 0;
            return index;
        }
        return (index - 1) / 2;
    }
    
    int getLeftChildIndex(int index) {
        return index * 2 + 1;
    }
    
    int getRightChildIndex(int index) {
        return index * 2 + 2;
    }
    
    void swap(MaxHeap* heap, int index1, int index2) {
        int temp = heap->data[index1];
        heap->data[index1] = heap->data[index2];
        heap->data[index2] = temp;
    }
    
    void heapifyUp(MaxHeap* heap) {
        int lastIndex = heap->size - 1;
        while (heap->data[getParentIndex(lastIndex)] < heap->data[lastIndex]) {
            int parentIndex = getParentIndex(lastIndex);
            swap(heap, parentIndex, lastIndex);
            lastIndex = parentIndex;
        }
    }
    
    void heapifyDown(MaxHeap* heap, int firstIndex) {
        while (getLeftChildIndex(firstIndex) < heap->size) {
            int biggestSiblingIndex = getLeftChildIndex(firstIndex);
            if (getRightChildIndex(firstIndex) < heap->size &&
                heap->data[getRightChildIndex(firstIndex)] > heap->data[biggestSiblingIndex]) {
                biggestSiblingIndex = getRightChildIndex(firstIndex);
            }
            if (heap->data[firstIndex] < heap->data[biggestSiblingIndex]) {
                swap(heap, firstIndex, biggestSiblingIndex);
                firstIndex = biggestSiblingIndex;
            } else {
                return;
            }
        }
    }
    
    void add(MaxHeap* heap, int value) {
        if (!contains(heap, value)) {
            heap->data[heap->size] = value;
            heap->size++;
            heapifyUp(heap);
        }
    }
    
    int extractMax(MaxHeap* heap) {
        if (heap->size == 0) {
            return -1; // indicating an empty heap
        }
        int firstIndex = 0;
        swap(heap, firstIndex, heap->size - 1);
        int max = heap->data[heap->size - 1];
        heap->size--;
        heapifyDown(heap, firstIndex);
        return max;
    }
    
    void clear(MaxHeap* heap) {
        heap->size = 0;
    }
    
    bool contains(MaxHeap* heap, int value) {
        for (int index = 0; index < heap->size; index++) {
            if (heap->data[index] == value) {
                return true;
            }
        }
        return false;
    }
    
    void printHeap(MaxHeap* heap) {
        printf("[");
        for (int index = 0; index < heap->size; index++) {
            printf("%d", heap->data[index]);
            if (index < heap->size - 1) {
                printf(", ");
            }
        }
        printf("]\n");
    }
    
    int main() {
        MaxHeap heap;
        heap.data = (int*)malloc(100 * sizeof(int)); // Assuming a maximum capacity of 100
        heap.size = 0;
    
        add(&heap, 10);
        add(&heap, 5);
        add(&heap, 15);
        printHeap(&heap); // Output: [15, 5, 10]
    
        int max = extractMax(&heap);
        printf("Extracted Max: %d\n", max); // Output: 15
        printHeap(&heap); // Output: [10, 5]
    
        free(heap.data);
        return 0;
    }
    
                </code>
            </pre>
            </article>

            <article class="p-article">
                <h2>Python</h2>
                <pre>
                <code class="language-python">
    class MaxHeap:
    def __init__(self):
        self.data = []
        self.size = 0

    def get_parent_index(self, index):
        if index <= 0:
            return 0
        return (index - 1) // 2

    def get_left_child_index(self, index):
        return index * 2 + 1

    def get_right_child_index(self, index):
        return index * 2 + 2

    def add(self, value):
        if value not in self.data:
            self.data.append(value)
            self.size += 1
            self.create_heap_levels()
            self.is_empty()
            self.get_size()
            self.heapify_up()

    def extract_max(self):
        if self.size == 0:
            return None
        first_index = 0
        self.swap(first_index, self.size - 1)
        max_value = self.data.pop()
        self.start_extract_max_animation(first_index, self.size - 1)
        self.size -= 1
        self.get_size()
        self.is_empty()
        self.heapify_down(first_index)
        return max_value

    def swap(self, index1, index2):
        self.data[index1], self.data[index2] = self.data[index2], self.data[index1]
        self.start_swap_animation(index1, index2)

    def heapify_up(self):
        last_index = self.size - 1
        while self.data[self.get_parent_index(last_index)] < self.data[last_index]:
            parent_index = self.get_parent_index(last_index)
            self.swap(parent_index, last_index)
            last_index = parent_index

    def heapify_down(self, first_index):
        while self.get_left_child_index(first_index) < self.size:
            biggest_sibling_index = self.get_left_child_index(first_index)
            if (
                self.get_right_child_index(first_index) < self.size
                and self.data[self.get_right_child_index(first_index)] > self.data[biggest_sibling_index]
            ):
                biggest_sibling_index = self.get_right_child_index(first_index)
            if self.data[first_index] < self.data[biggest_sibling_index]:
                self.swap(first_index, biggest_sibling_index)
                first_index = biggest_sibling_index
            else:
                return

    def get_size(self):
        size_output = f"Size: {self.size}"
        print(size_output)
        return self.size

    def is_empty(self):
        is_empty_output = f"isEmpty? {self.size == 0}"
        print(is_empty_output)
        return self.size == 0

    def contains(self, value):
        return value in self.data

    def clear(self):
        for index, node in enumerate(self.data):
        self.data = []
        self.size = 0
        self.is_empty()
        self.get_size()

    def build_max_heap(self):
        last_non_leaf_index = (self.size // 2) - 1
        for i in range(last_non_leaf_index, -1, -1):
            self.heapify_down(i)

    def to_string(self):
        result = "[" + ", ".join(map(str, self.data)) + "]"
        return result

                </code>
            </pre>
            </article>
        </section>
    </section>

    <!--Use type=module to import/export classes and src test file-->
    <script type="module" src="js/structures/maxheap-ui.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
        hljs.highlightAll();
    </script>
</body>

</html>