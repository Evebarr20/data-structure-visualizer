<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Binary Search Tree Visualizer</title>
    <meta name="description" content="">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="css/binarytree.css">

 <!-- Include Prism.css theme -->
 <link rel="stylesheet" href="./assets/library/prism.css">
</head>

<body>
    <div id="mySidenav" class="sidenav">
        <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
        <img src="./assets/img/InsertNaive.gif">
        <a href="#javaCode">Java Code</a>
        <a href="#cCode">C Code</a>
        <h2>What is a Binary Search Tree?</h2>
        <p>A binary search tree (BST) is a hierarchical data structure widely used in computer science 
        for efficient searching, insertion, and deletion operations. In a binary search tree, each node has at most two children, 
        referred to as the left child and the right child. The structure of the tree is such that for each node, all elements in its left subtree are less than or equal to the node, while all elements in its right subtree are greater than the node.
        </p>
        <h2>How To insert?</h2>
        <p>When inserting a new node, if the tree is initially empty, the first node becomes the root. 
            Subsequent nodes are added based on a comparison with the existing nodes: if the value is less than or equal to the parent, it goes to the left; 
            if greater, it goes to the right. 
        </p>
        <h2>How To remove?</h2>
        <p>In the removal process, if a node is a leaf <mark>(has no children)</mark>, it is simply deleted. 
            If a node has one child, the child's value replaces the parent's value. 
            When a node has two children, the maximum node in the leftmost subtree becomes the parent, ensuring the integrity of the BST.
        </p>
        <h2>What Are Traversals?</h2>
        <p>In the realm of binary search trees (BSTs), traversals play a crucial role in understanding the organization and relationships among nodes. 
            <mark>The inorder traversal</mark>, a cornerstone operation, starts from the leftmost node, progressing to the root, and then moves to the right subtree. 
            Notably, this traversal yields a sorted sequence of nodes, offering a convenient means of obtaining elements in ascending order. 
            In contrast, <mark>the preorder traversal</mark> initiates from the root, extends to the left subtree, and concludes with the right subtree. 
            This traversal aids in constructing prefix expressions and facilitates deep copying of the tree. 
        <mark>The postorder traversal</mark>, commencing from the leftmost node, proceeds to the right subtree, and ultimately reaches the root. 
            Its utility lies in bottom-up operations, such as node deletion or expression evaluation in postfix expression trees. 
            These traversals collectively provide distinct perspectives on the hierarchical structure of a BST, each serving specific purposes in various applications.
        </p>
        <section id="javaCode">
            <h2>Code</h2>
            <!-- Inline code snippet -->
            <p>Java Code Sample:</p>
            <pre><code class="language-java">
                public class bst { //Define a public class named bst
                    private Node root; //Declare a private instance variable "root" of type node
                
                    private class Node { //Define a private inner class named "Node"
                        Node left; //Declare a left child Node
                        Node right; //Declare a right child Node
                        int data; //Declare a data variable of type int
                
                        public Node(int newData) { //Constructor for the Node class, initializes left, right, and data
                            left = null;
                            right = null;
                            data = newData;
                        }
                    }
                
                    public void binarySearchTree() { //constructor for the bst class, initializes the root to null
                        root = null; //creates empty binary tree
                    }
                
                    public void add(int data) { //public method to add a node with the given data to the bst
                        root = add(root, data); //call the private add method with the root and the given data
                    }
                    private Node add(Node node, int data) { //private method to recursively add a node with the given data to the bst
                        if(node == null) { //checks if the current node is null
                            node = new Node(data); //create a new node with the data if so
                        }
                        else {
                            if(data <= node.data) { //if the data is less than or equal to the current node's data
                                node.left = add(node.left, data); //recursively add to the left subtree
                            }
                            else { //if the data is greater
                                node.right = add(node.right, data); //recursively add to the right subtree
                            }
                        }
                        return node; //return the modified code
                    }
                
                    public void remove(int data) { //public method to remove a node with the given data to the bst
                        root = remove(root, data); //call the private remove method with the root and the given data
                    }
                
                    private Node remove(Node node, int data) { // Private method to remove a node with the given data from the binary search tree
                        if(node == null) { // Base case: if the current node is null, return null (no change)
                            return null;
                        }
                        if(data < node.data) {  // If the data to be deleted is smaller than the root's data, then it lies in the left subtree
                            node.left = remove(node.left, data);  // Recursively call remove on the left subtree
                        }
                        else if(data > node.data) {  // If the data to be deleted is greater than the root's data, then it lies in the right subtree
                            node.right = remove(node.right, data);  // Recursively call remove on the right subtree
                        }
                        // If the data to be deleted is the same as the root's data,
                        // then this is the node to be deleted
                        else {
                            if(node.left == null && node.right == null) { // Case 1: Node with no children
                                return null; // Simply remove the node by returning null
                            }
                            if(node.left == null) { // Case 2: Node with only a right child
                                return node.right; // Replace the node with its right child
                            }
                            else if(node.right == null) { // Case 3: Node with only a left child
                                return node.left; // Replace the node with its left child
                            }
                            else {  // Case 4: Node with two children
                                Node maxNode = findMaxValueNode(node.left);  // Find the maximum value node in the left subtree
                                node.data = maxNode.data;  // Replace the current node's data with the maxNode's data
                                node.left = remove(node.left, maxNode.data);  // Recursively remove the maxNode from the left subtree
                            }
                
                        }
                        return node;
                    }
                    private Node findMaxValueNode(Node node) { // Private method to find and return the node with the maximum value in the binary search tree
                        if(node == null) { // Base case: if the current node is null, the tree is empty, return null
                            return null;
                        }
                        while(node.right != null) { // Traverse to the right child until the right child is null, which is the maximum value node
                            node = node.right;
                        }
                        return node; // Return the node with the maximum value
                    }
                    private void inOrderTraversal(Node node) {
                        if(node != null) {
                            inOrderTraversal(node.left);
                            System.out.print(node.data + " ");
                            inOrderTraversal(node.right);
                        }
                    }
                    public static void main(String[] args) {
                        // Create an instance of the bst class
                        bst binarySearchTree = new bst();
                
                        // Test the add method
                        binarySearchTree.add(50);
                        binarySearchTree.add(30);
                        binarySearchTree.add(70);
                
                        // Print the tree to verify the add operation
                        System.out.println("Binary Search Tree after adding elements:");
                        binarySearchTree.inOrderTraversal(binarySearchTree.root);
                
                        // Test the remove method
                        binarySearchTree.remove(30);
                
                        // Print the tree to verify the remove operation
                        System.out.println("\nBinary Search Tree after removing 30:");
                        binarySearchTree.inOrderTraversal(binarySearchTree.root);
                    }
                }</code></pre>
        </section>
        <section id="cCode">
            <p></p>
            <p>C Code Sample:</p>
            <pre><code class="language-c">
                #include  &lt;stdio.h&gt;
                    #include &lt;stdlib.h&gt;
                    struct Node* findMaxValueNode(struct Node* node);
                    struct Node { //Define a structure for the Node
                        struct Node* left; //pointer to the left child node
                        struct Node* right; //pointer to the right child node
                        int data; //data stored in node
                    };
                    
                    struct bst { //Define a structure for the Binary Search Tree
                        struct Node* root; //pointer to the root node of the tree
                    };
                    
                    struct Node* createNode(int newData) { //Define a function to create a new Node with the given data
                        //allocate memory for a new node structure using malloc
                        struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
                        //set the left and right pointers of the new node to NULL
                        newNode->left = NULL;
                        newNode->right = NULL;
                        newNode->data = newData; //set the data of the new node to the provided newData
                        return newNode; //return the newly created node
                    }
                    struct bst* createBST() {
                        //allocate memory for a new binary search tree
                        struct bst* newBST = (struct bst*)malloc(sizeof(struct bst));
                        // Initialize the root pointer of the new bst to NULL (indicating an empty tree)
                        newBST->root = NULL;
                        return newBST; //return the newly created bst
                    }
                    // Private method to recursively add a node with the given data to the bst
                    struct Node* add(struct Node* node, int data) {
                        if(node == NULL) {
                            return createNode(data); // If the current node is null, create a new node with the given data
                        }
                        else {
                            if(data <= node->data) {
                                node->left = add(node->left, data); // Recursively add to the left subtree
                            }
                            else {
                                node->right = add(node->right, data); // Recursively add to the right subtree
                            }
                        }
                        return node; // Return the modified node
                    }
                    void addData(struct bst* tree, int data) { // Public method to add a node with the given data to the bst
                        tree->root = add(tree->root, data); // Call the private add method with the root and the given data
                    }
                    
                    // Private method to recursively remove a node with the given data from the bst
                    struct Node* removeNode(struct Node* node, int data) {
                        if(node == NULL) {
                            return NULL; // Base case: If the current node is null, no change
                        }
                        if(data < node->data) {
                            node->left = removeNode(node->left, data); // Recursively call remove on the left subtree
                        }
                        else if(data > node->data) {
                            node->right = removeNode(node->right, data); // Recursively call remove on the right subtree
                        }
                        else {
                            if(node->left == NULL && node->right == NULL) { // Case 1: Node with no children
                                free(node); // Simply remove the node by freeing the memory
                                return NULL;
                            }
                            else if(node->left == NULL) { // Case 2: Node with only a right child
                                struct Node* temp = node->right;
                                free(node);
                                return temp;  // Replace the node with its right child
                            }
                            if(node->right == NULL) { // Case 3: Node with only a left child
                                struct Node* temp = node->left;
                                free(node);
                                return temp;  // Replace the node with its left child
                            }
                            else { // Case 4: Node with two children
                                struct Node* maxNode = findMaxValueNode(node->left); // Find the maximum value node in the left subtree
                                node->data = maxNode->data; // Replace the current node's data with the maxNode's data
                                // Recursively remove the maxNode from the left subtree
                                node->left = removeNode(node->left, maxNode->data);
                            }
                        }
                        return node;
                    }
                    void removeData(struct bst* tree, int data) { // Public method to remove a node with the given data from the bst
                        tree->root = removeNode(tree->root, data); // Call the private remove method with the root and the given data
                    }
                    
                    // Private method to find and return the node with the maximum value in the binary search tree
                    struct Node* findMaxValueNode(struct Node* node) {
                        if(node == NULL) {
                            return NULL; // Base case: If the current node is null, the tree is empty, return null
                        }
                        while(node->right != NULL) {
                            node = node->right; // Traverse to the right child until the right child is null, which is the maximum value node
                        }
                        return node; // Return the node with the maximum value
                    }
                    
                    void inOrderTraversal(struct Node* node) { // Private method for in-order traversal
                        if(node != NULL) {
                            inOrderTraversal(node->left);
                            printf("%d ", node->data);
                            inOrderTraversal(node->right);
                        }
                    }
                    
                    int main() {
                        struct bst* binarySearchTree = createBST(); //create an instance of the bst struct
                    
                        //test the add method
                        addData(binarySearchTree,50);
                        addData(binarySearchTree,30);
                        addData(binarySearchTree,70);
                    
                        //print the tree to verify the add operation
                        printf("Binary Search Tree after adding elements: ");
                        inOrderTraversal(binarySearchTree->root);
                    
                        //test the remove method
                        removeData(binarySearchTree, 30);
                    
                        //print the tree to verify the remove operation
                        printf("\nBinary Search Tree after removing 30: ");
                        inOrderTraversal(binarySearchTree->root);
                        return 0;
                    }</code></pre>
        </section>
        
    </div>
    <header>
        <h1>Binary Search Tree Visualizer</h1>
        <span class="openbtn" onclick="openNav()">&#9776;</span>
    </header>
        <nav class="nav">
            <article class="add-container">
                <input type="text" placeholder="Insert Node Value" class="add-input-val" required>
                <button class="add-node-btn">Insert Node</button>
            </article>
    
            <article class="delete-container">
                <input type="text" placeholder="Delete Node Value" class="delete-input-val" required>
                <button class="delete-node-btn">Delete Node</button>
            </article>
    
            <article class="search-container">
                <input type="text" placeholder="Search Node" class="search-input-val">
                <button class="search-node-btn">Search Node</button>
            </article>
        </nav>
        <section class="button-section">
            <button class="searchmin-node-btn">Search Min Node</button>
            <button class="searchmax-node-btn">Search Max Node</button>
            <button class="inorder-node-btn">Inorder Traversal</button>
            <button class="postorder-node-btn">Postorder Traversal</button>
            <button class="preorder-node-btn">Preorder Traversal</button>
            <button class="clear-btn">Clear</button>
        </section>

        <div class="home-container">
            <a href="index.html" class="home-button" id="home-button">Home</a>
        </div>

        
        <div id="error-message" class="error-message" style="color: red;"></div>

        <article class="holder">
            <!---Binary Tree Results go here-->
            <section class="binarytree-container">
                <!-- <div class="bst-node">1</div>
            <div class="bst-node">3</div>
            <div class="bst-node">4</div> -->
            </section>
        </article>

        <main class="bst-main">
            <section class="bst-container"></section>
        </main>
    <script type="module" src="js/structures/BST_UI.js" async></script>
     <!-- Include Prism.js script -->
    <script src="./assets/library/prism.js"></script>

</body>

</html>
